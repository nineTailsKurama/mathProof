/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou
-/
import data.set.pointwise
import order.filter.basic

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Principal filter at `0 : Œ±`.
* `1` (`filter.has_one`): Principal filter at `1 : Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.

## TODO

Add missing operations: subtraction/division, negation/inversion, scalar multiplication/addition

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/

open set
open_locale pointwise

universes u v w
variables {F : Type*} {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

namespace filter

/-- `1 : filter Œ±` is the set of sets containing `1 : Œ±`. -/
@[to_additive "`0 : filter Œ±` is the set of sets containing `0 : Œ±`."]
instance [has_one Œ±] : has_one (filter Œ±) := ‚ü®principal 1‚ü©

@[simp, to_additive]
lemma mem_one [has_one Œ±] {s : set Œ±} : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := one_subset

@[to_additive]
lemma one_mem_one [has_one Œ±] : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_principal_self _

@[to_additive]
instance [has_mul Œ±] : has_mul (filter Œ±) := ‚ü®Œª f g,
{ sets             := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s},
  univ_sets        := ‚ü®univ, univ, univ_sets _, univ_sets _, subset_univ _‚ü©,
  sets_of_superset := Œªx y hx hxy,
    Exists‚ÇÇ.imp (Œª t‚ÇÅ t‚ÇÇ, and.imp_right $ and.imp_right $ Œª h, subset.trans h hxy) hx,
  inter_sets       := Œªx y,
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff],
    rintros ‚ü®s‚ÇÅ, s‚ÇÇ, hs‚ÇÅ, hs‚ÇÇ, s‚ÇÅs‚ÇÇ‚ü© ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©,
    exact ‚ü®s‚ÇÅ ‚à© t‚ÇÅ, s‚ÇÇ ‚à© t‚ÇÇ, inter_sets f hs‚ÇÅ ht‚ÇÅ, inter_sets g hs‚ÇÇ ht‚ÇÇ,
      (mul_subset_mul (inter_subset_left _ _) $ inter_subset_left _ _).trans s‚ÇÅs‚ÇÇ,
      (mul_subset_mul (inter_subset_right _ _) $ inter_subset_right _ _).trans t‚ÇÅt‚ÇÇ‚ü©,
  end }‚ü©

@[to_additive]
lemma mem_mul [has_mul Œ±] {f g : filter Œ±} {s : set Œ±} :
  s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl

@[to_additive]
lemma mul_mem_mul [has_mul Œ±] {f g : filter Œ±} {s t : set Œ±} (hs : s ‚àà f) (ht : t ‚àà g) :
  s * t ‚àà f * g := ‚ü®_, _, hs, ht, subset.rfl‚ü©

@[to_additive]
protected lemma mul_le_mul [has_mul Œ±] {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) :
  f‚ÇÅ * g‚ÇÅ ‚â§ f‚ÇÇ * g‚ÇÇ := assume _ ‚ü®s, t, hs, ht, hst‚ü©, ‚ü®s, t, hf hs, hg ht, hst‚ü©

@[to_additive]
lemma ne_bot.mul [has_mul Œ±] {f g : filter Œ±} : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) :=
begin
  simp only [forall_mem_nonempty_iff_ne_bot.symm],
  rintros hf hg s ‚ü®a, b, ha, hb, ab‚ü©,
  exact ((hf a ha).mul (hg b hb)).mono ab
end

@[to_additive]
instance [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, filter.ext $ Œª s, begin
    split,
    { rintro ‚ü®a, b, ‚ü®a‚ÇÅ, a‚ÇÇ, ha‚ÇÅ, ha‚ÇÇ, a‚ÇÅa‚ÇÇ‚ü©, hb, ab‚ü©,
      refine ‚ü®a‚ÇÅ, a‚ÇÇ * b, ha‚ÇÅ, mul_mem_mul ha‚ÇÇ hb, _‚ü©,
      rw ‚Üêmul_assoc,
      exact (mul_subset_mul a‚ÇÅa‚ÇÇ subset.rfl).trans ab },
    { rintro ‚ü®a, b, ha, ‚ü®b‚ÇÅ, b‚ÇÇ, hb‚ÇÅ, hb‚ÇÇ, b‚ÇÅb‚ÇÇ‚ü©, ab‚ü©,
      refine ‚ü®a * b‚ÇÅ, b‚ÇÇ, mul_mem_mul ha hb‚ÇÅ, hb‚ÇÇ, _‚ü©,
      rw mul_assoc,
      exact (mul_subset_mul subset.rfl b‚ÇÅb‚ÇÇ).trans ab }
  end }

@[to_additive]
instance [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, filter.ext $ Œª s, exists_comm.trans $ exists‚ÇÇ_congr $ Œª t‚ÇÅ t‚ÇÇ,
    by rw [and.left_comm, mul_comm],
  ..filter.semigroup }

@[to_additive]
instance [mul_one_class Œ±] : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, filter.ext $ Œª s, begin
    refine ‚ü®_, Œª hs,  ‚ü®1, s, one_mem_one, hs, (one_mul _).subset‚ü©‚ü©,
    rintro ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©,
    exact mem_of_superset ht‚ÇÇ ((subset_mul_right _ $ mem_one.1 ht‚ÇÅ).trans t‚ÇÅt‚ÇÇ),
  end,
  mul_one := Œª f, filter.ext $ Œª s, begin
    refine ‚ü®_, Œª hs, ‚ü®s, 1, hs, one_mem_one, (mul_one _).subset‚ü©‚ü©,
    rintro ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©,
    exact mem_of_superset ht‚ÇÅ ((subset_mul_left _ $ mem_one.1 ht‚ÇÇ).trans t‚ÇÅt‚ÇÇ),
  end }

@[to_additive]
instance [monoid Œ±] : monoid (filter Œ±) := { ..filter.mul_one_class, ..filter.semigroup }

@[to_additive]
instance [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }

section map

variables [monoid Œ±] [monoid Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±}

@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
begin
  ext s,
  split,
  { rintro ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©,
    have : m '' (t‚ÇÅ * t‚ÇÇ) ‚äÜ s := subset.trans (image_subset m t‚ÇÅt‚ÇÇ) (image_preimage_subset _ _),
    exact ‚ü®m '' t‚ÇÅ, m '' t‚ÇÇ, image_mem_map ht‚ÇÅ, image_mem_map ht‚ÇÇ, by rwa ‚Üê image_mul m‚ü© },
  { rintro ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©,
    refine ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, image_subset_iff.1 _‚ü©,
    rw image_mul m,
    exact (mul_subset_mul (image_preimage_subset _ _) $ image_preimage_subset _ _).trans t‚ÇÅt‚ÇÇ }
end

@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
le_antisymm
  (le_principal_iff.2 $ mem_map_iff_exists_image.2 ‚ü®1, one_mem_one, Œª x, by simp [map_one œÜ]‚ü©)
  (le_map $ Œª s hs, mem_one.2 ‚ü®1, mem_one.1 hs, map_one œÜ‚ü©)

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }

-- The other direction does not hold in general.
@[to_additive]
lemma comap_mul_comap_le [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ f‚ÇÇ : filter Œ≤} :
  f‚ÇÅ.comap m * f‚ÇÇ.comap m ‚â§ (f‚ÇÅ * f‚ÇÇ).comap m  :=
Œª s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©,
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans $ (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
lemma tendsto.mul_mul [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) :=
Œª hf hg, (filter.map_mul m).trans_le $ filter.mul_le_mul hf hg

end map

end filter
